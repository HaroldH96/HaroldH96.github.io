<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python爬虫笔记05-多线程基本原理</title>
      <link href="/2022/04/28/python-pa-chong-bi-ji-05-duo-xian-cheng-ji-ben-yuan-li/"/>
      <url>/2022/04/28/python-pa-chong-bi-ji-05-duo-xian-cheng-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="05：多路加速，了解多线程基本原理"><a href="#05：多路加速，了解多线程基本原理" class="headerlink" title="05：多路加速，了解多线程基本原理"></a>05：多路加速，了解多线程基本原理</h1><p>我们知道，在一台计算机中，我们可以同时打开许多软件，比如同时浏览网页、听音乐、打字等等，看似非常正常。但仔细想想，为什么计算机可以做到这么多软件同时运行呢？这就涉及到计算机中的两个重 要概念：多进程和多线程了。 同样，在编写爬虫程序的时候，为了提高爬取效率，我们可能想同时运行多个爬虫任务。这里同样需要涉及多进程和多线程的知识。 本课时，我们就先来了解一下多线程的基本原理，以及在 Python中如何实现多线程。  </p><h2 id="5-1-多线程的含义"><a href="#5-1-多线程的含义" class="headerlink" title="5.1 多线程的含义"></a>5.1 多线程的含义</h2><p>说起多线程，就不得不先说什么是线程。然而想要弄明白什么是线程，又不得不先说什么是进程。 </p><p><strong>进程</strong>可以理解为是一个<strong>可以独立运行的程序单位</strong>，<br>比如：</p><ul><li>打开一个浏览器，这就开启了一个浏览器进程</li><li>打开一个文本编辑器，这就开启了一个文本编辑器进程。</li></ul><p><strong>一个进程中是可以同时处理很多事情</strong><br>比如：</p><p>在浏览器中，我们可以在多个选项卡中打开多个页面<br>有的页面在播放音乐，有的页面在播放视频，有的网页在播放动画<br>可以同时运行，互不干扰。</p><p>为什么能同时做到同时运行这么多的任务呢？这里就需要引出线程的概念了，其实这一个个任务，实际上就对应着一个个线程的执行。 </p><p><strong>进程</strong>是线程的集合，进程就是由一个或多个线程构成的<br><strong>线程</strong>是操作系统进行运算调度的最小单位，是进程中的一个最小运行单元。</p><p>比如上面所说的浏览器进程，其中的播放音乐就是一个线程，播放视频也是一个线程，当然其中还有很多其他的线程在同时运行，这些线程的并发或并行执行最后使得整个浏览器可以同时运行这么多的任务。 了解了线程的概念，多线程就很容易理解了，<strong>多线程就是一个进程中同时执行多个线程</strong>，前面所说的浏览器的情景就是典型的多线程执行。 </p><h2 id="5-2-并发和并行"><a href="#5-2-并发和并行" class="headerlink" title="5.2 并发和并行"></a>5.2 并发和并行</h2><p>说到多进程和多线程，这里就需要再讲解两个概念，那就是并发和并行。我们知道，一个程序在计算机中运行，其底层是处理器通过运行一条条的指令来实现的。 </p><h3 id="5-2-1-并发-concurrency"><a href="#5-2-1-并发-concurrency" class="headerlink" title="5.2.1 并发 concurrency"></a>5.2.1 <strong>并发</strong> concurrency</h3><center>指同一时刻只能有一条指令执行</center><center>但多个线程的对应的指令被快速轮换地执行</center><center>宏观上看起来多个线程在同时运行</center><center>但微观上只是这个处理器在连续不断地在多个线程之间切换和执行</center><center>每个线程的执行一定会占用这个处理器一个时间片段</center><center>同一时刻，其实只有一个线程在执行</center><h3 id="5-2-2-并行-parallel"><a href="#5-2-2-并行-parallel" class="headerlink" title="5.2.2 并行 parallel"></a>5.2.2 <strong>并行</strong> parallel</h3><center>指同一时刻有多条指令在多个处理器上同时执行</center><center>并行必须要依赖于多个处理器</center><center>不论是从宏观上还是微观上，多个线程都是在同一时刻一起执行的</center><center>并行只能在多处理器系统中存在</center><center>如果计算机处理器只有一个核，那就不可能实现并行</center><blockquote>而并发在单处理器和多处理器系统中都是可以存在的，因为仅靠一个核，就可以实现并发。 举个例子，比如系统处理器需要同时运行多个线程。如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个 线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。 </blockquote>## 5.3 多线程适用场景<p><strong>在一个程序进程中，有一些操作是比较耗时或者需要等待的</strong><br>比如：</p><ul><li>等待数据库的查询结果的返回</li><li>等待网页结果的响应</li></ul><p><img src="/2022/04/28/python-pa-chong-bi-ji-05-duo-xian-cheng-ji-ben-yuan-li/1651152599781.png" alt="单线程和多线程"></p><p>像上述场景，线程在执行过程中很多情况下是需要等待的。<br>比如<strong>网络爬虫</strong>就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于 <strong>IO 密集型任务</strong>。<br>对于这种任务，如果我们启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。 </p><p>但并不是所有的任务都是 IO 密集型任务，还有一种任务叫作<strong>计算密集型任务</strong>，也可以称之为 <strong>CPU 密集型任务</strong>。<br>顾名思义，就是任务的运行一直需要处理器的参与。<br>此时如果我们开启了多线程，一个处理器从 一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。<br>如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p><p> 所以，如果任务不全是计算密集型任务，我们可以使用多线程来提高程序整体的执行效率。尤其<strong>对于网络爬虫这种 IO 密集型任务</strong>来说，<strong>使用多线程会大大提高程序整体的爬取效率</strong>。 </p><h2 id="5-4-Python-实现多线程"><a href="#5-4-Python-实现多线程" class="headerlink" title="5.4 Python 实现多线程"></a>5.4 Python 实现多线程</h2><p>在 Python中，实现多线程的模块叫作 <strong>threading</strong>，是 Python自带的模块。<br>下面我们来了解下使用 threading实现多线程的方法。 </p><h3 id="5-4-1-Thread直接创建子线程"><a href="#5-4-1-Thread直接创建子线程" class="headerlink" title="5.4.1 Thread直接创建子线程"></a>5.4.1 Thread直接创建子线程</h3><p>首先，我们可以使用 Thread 类来创建一个线程，创建时需要指定 target 参数为运行的方法名称，如果被调用的方法需要传入额外的参数，则可以通过 Thread 的 args 参数来指定。示例如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">target</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is running'</span></span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> sleep </span><span class="token interpolation"><span class="token punctuation">{</span>second<span class="token punctuation">}</span></span><span class="token string">s'</span></span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is ended'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is running'</span></span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>target<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is ended'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行结果如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Threading MainThread <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> sleep 1sThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">2</span> sleep 5sThreading MainThread <span class="token keyword">is</span> endedThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> endedThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><div>在这里我们首先声明了一个方法，叫作 target，它接收一个参数为 second，通过方法的实现可以发现，这个方法其实就是执行了一个 time.sleep 休眠操作，second 参数就是休眠秒数，其前后都 print 了一些内容， 其中线程的名字我们通过 threading.current_thread().name 来获取出来，如果是主线程的话，其值就是 MainThread，如果是子线程的话，其值就是 Thread-*。</div>    <div>然后我们通过 Thead 类新建了两个线程，target 参数就是刚才我们所定义的方法名，args 以列表的形式传递。两次循环中，这里 i分别就是 1 和 5，这样两个线程就分别休眠 1 秒和 5 秒，声明完成之后，我们调用 start 方法即可开始线程的运行。</div>    <div>观察结果我们可以发现，这里一共产生了三个线程，分别是主线程 MainThread 和两个子线程 Thread-1、Thread-2。</div>    <div>另外我们观察到，主线程首先运行结束，紧接着 Thread-1、Thread-2 才接连运行结束，分别间隔 了 1 秒和 4 秒。这说明主线程并没有等待子线程运行完毕才结束运行，而是直接退出了，有点不符合常理。</div> </blockquote><p>如果我们<strong>想要主线程等待子线程运行完毕之后才退出</strong>，可以让每个<strong>子线程对象都调用下 join方法</strong>，实现如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>target<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>thread<span class="token punctuation">)</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行结果如下：  </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Threading MainThread <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> sleep 1sThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">2</span> sleep 5sThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> endedThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> endedThreading MainThread <span class="token keyword">is</span> ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这样，主线程必须等待子线程都运行结束，主线程才继续运行并结束。 </p><h3 id="5-4-2-继承-Thread类创建子线程"><a href="#5-4-2-继承-Thread类创建子线程" class="headerlink" title="5.4.2 继承 Thread类创建子线程"></a>5.4.2 继承 Thread类创建子线程</h3><p>另外，我们也可以通过<strong>继承 Thread 类</strong>的方式创建一个线程，该线程<strong>需要执行的方法写在类的 run方法里面</strong>即可。上面的例子的等价改写为： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">:</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>self<span class="token punctuation">.</span>second <span class="token operator">=</span> second        <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is running'</span></span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> sleep </span><span class="token interpolation"><span class="token punctuation">{</span>self<span class="token punctuation">.</span>second<span class="token punctuation">}</span></span><span class="token string">s'</span></span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>self<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is ended'</span></span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is running'</span></span><span class="token punctuation">)</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">:</span>thread <span class="token operator">=</span> MyThread<span class="token punctuation">(</span>i<span class="token punctuation">)</span>threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>thread<span class="token punctuation">)</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is ended'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 运行结果如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Threading MainThread <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> sleep 1sThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">2</span> sleep 5sThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> endedThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> endedThreading MainThread <span class="token keyword">is</span> ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-5-守护线程"><a href="#5-5-守护线程" class="headerlink" title="5.5 守护线程"></a>5.5 守护线程</h2><p>在线程中有一个叫作<strong>守护线程</strong>的概念，如果一个线程被设置为守护线程，那么意味着这个线程是“<strong>不重要</strong>”的，这意味着，如果主线程结束了而该守护线程还没有运行完，那么它将会被强制结束。在 Python中我 们可以通过 <strong>setDaemon</strong> 方法来将某个线程设置为守护线程。 示例如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">target</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is running'</span></span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> sleep </span><span class="token interpolation"><span class="token punctuation">{</span>second<span class="token punctuation">}</span></span><span class="token string">s'</span></span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is ended'</span></span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is running'</span></span><span class="token punctuation">)</span>t1 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>target<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>target<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>setDaemon<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Threading </span><span class="token interpolation"><span class="token punctuation">{</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">}</span></span><span class="token string"> is ended'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里我们通过 setDaemon方法将 t2 设置为了守护线程，这样主线程在运行完毕时，t2 线程会随着线程的结束而结束。<br>运行结果如下：  </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Threading MainThread <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> runningThreading Thread<span class="token operator">-</span><span class="token number">1</span> sleep 2sThreading Thread<span class="token operator">-</span><span class="token number">2</span> <span class="token keyword">is</span> runningThreading MainThread <span class="token keyword">is</span> endedThreading Thread<span class="token operator">-</span><span class="token number">2</span> sleep 5sThreading Thread<span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">is</span> ended<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，我们没有看到 Thread-2 打印退出的消息，Thread-2 随着主线程的退出而退出了。 </p><blockquote>这里并没有调用 join方法，如果我们让 t1 和 t2 都调用 join方法，主线程就会仍然等待各个子线程执行完毕再退出，不论其是否是守护线程。</blockquote>  ## 5.6 互斥锁<p><strong>在一个进程中的多个线程是共享资源的</strong>，比如在一个进程中，有一个全局变量 count 用来计数，现在我们声明多个线程，每个线程运行时都给 count 加 1，让我们来看看效果如何，代码实现如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timecount <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">global</span> counttemp <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.001</span><span class="token punctuation">)</span>count <span class="token operator">=</span> temp        threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>thread <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>thread<span class="token punctuation">)</span>    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Final count: </span><span class="token interpolation"><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里，我们声明了 1000 个线程，每个线程都是现取到当前的全局变量 count 值，然后休眠一小段时间，然后对 count 赋予新的值。 那这样，按照常理来说，最终的 count 值应该为 1000。但其实不然，我们来运行一下看看。 运行结果如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Final count<span class="token punctuation">:</span> <span class="token number">69</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后的结果居然只有 69，而且多次运行或者换个环境运行结果是不同的。</p><p>这是为什么呢？因为 count 这个值是共享的，每个线程都可以在执行 temp = count 这行代码时拿到当前 count 的值，但是这些线程中的一些线程可能是并发或者并行执行的，这就导致不同的线程拿到的可能是同一个 count 值，最后导致有些线程的 count 的加 1 操作并没有生效，导致最后的结果偏小。<br>所以，如果多个线程同时对某个数据进行读取或修改，就会出现不可预料的结果。<br>为了避免这种情况，我们需要对多个线程进行同步，要实现同步，我们可以<strong>对需要操作的数据进行加锁保护</strong>，这里就需要用到 <strong>threading.Lock</strong> 了。<br>加锁保护是什么意思呢？就是说，某个线程在对数据进行操作前，需要先加锁，这样其他的线程发现被加锁了之后，就无法继续向下执行，会一直<strong>等待锁被释放</strong>，只有加锁的线程把锁释放了，其他的线程才能继续加锁并对数据做修改，修改完了再释放锁。<br>这样可以<strong>确保同一时间只有一个线程操作数据</strong>，<strong>多个线程不会再同时读取和修改同一个数据</strong>，这样最后的运行结果就是对的了。 我们可以将代码修改为如下内容： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> timecount <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">global</span> countlock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>temp <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.001</span><span class="token punctuation">)</span>count <span class="token operator">=</span> templock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>        lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>thread <span class="token operator">=</span> MyThread<span class="token punctuation">(</span><span class="token punctuation">)</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>thread<span class="token punctuation">)</span>    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Final count: </span><span class="token interpolation"><span class="token punctuation">{</span>count<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这里我们声明了一个 lock 对象，其实就是 threading.Lock 的一个实例，然后在 run方法里面，获取 count 前先加锁，修改完 count 之后再释放锁，这样多个线程就不会同时获取和修改 count 的值了。 运行结果如下： </p><pre class="line-numbers language-python" data-language="python"><code class="language-python">Final count<span class="token punctuation">:</span> <span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样运行结果就正常了。<br>关于 Python多线程的内容，这里暂且先介绍这些，关于 theading更多的使用方法，如信号量、队列等，可以参考官方文档：<a href="https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading">https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading</a></p><h2 id="5-7-Python-多线程的问题"><a href="#5-7-Python-多线程的问题" class="headerlink" title="5.7 Python 多线程的问题"></a>5.7 Python 多线程的问题</h2><p>由于 Python中 GIL的限制，导致不论是在单核还是多核条件下，在同一时刻只能运行一个线程，导致 Python多线程无法发挥多核并行的优势。 </p><p><strong>GIL</strong>全称为 GlobalInterpreter Lock，中文翻译为<strong>全局解释器锁</strong>，其最初设计是出于数据安全而考虑的。<br>在 Python多线程下，每个线程的执行方式如下：  </p><ul><li>获取 GIL</li><li>执行对应线程的代码</li><li>释放 GIL</li></ul><p>可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL看作是通行证，并且在<strong>一个 Python进程中，GIL只有一个</strong>。拿不到通行证的线程，就不允许执行。<br>这样就会导致，即使是多核条件下，一个 Python 进程下的多个线程，同一时刻也只能执行一个线程。</p><p>不过对于爬虫这种 IO 密集型任务来说，这个问题影响并不大。而对于计算密集型任务来说，由于 GIL的存在，多线程总体的运行效率相比可能反而比单线程更低 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记04-Session与Cookies</title>
      <link href="/2022/04/28/python-pa-chong-bi-ji-04-session-yu-cookies/"/>
      <url>/2022/04/28/python-pa-chong-bi-ji-04-session-yu-cookies/</url>
      
        <content type="html"><![CDATA[<h1 id="04：基础探究，Session-与-Cookies"><a href="#04：基础探究，Session-与-Cookies" class="headerlink" title="04：基础探究，Session 与 Cookies"></a>04：基础探究，Session 与 Cookies</h1><p>我们在浏览网站的过程中，经常会遇到需要登录的情况，而有些网页只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登录。 还有一些网站，在打开浏览器时就自动登录了，而且很长时间都不会失效，这种情况又是为什么？其实这里面涉及 Session和 Cookies 的相关知识，本节就来揭开它们的神秘面纱。 </p><h2 id="4-1-静态网页和动态网页"><a href="#4-1-静态网页和动态网页" class="headerlink" title="4.1 静态网页和动态网页"></a>4.1 静态网页和动态网页</h2><p>在开始介绍它们之前，我们需要先了解一下静态网页和动态网页的概念。这里还是前面的示例代码，内容如下： </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>This is a Demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Hello, this is a paragraph.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是最基本的 HTML代码，我们将其保存为一个 .html文件，然后把它放在某台具有固定公网 IP 的主机上，主机上装上 Apache 或 Nginx等服务器，这样这台主机就可以作为服务器了，其他人便可以通过访问服 务器看到这个页面，这就搭建了一个最简单的网站。 </p><ul><li>这种网页的内容是 HTML代码编写的</li><li>文字、图片等内容均通过写好的 HTML代码来指定</li><li>这种页面叫作<strong>静态网页</strong></li><li>它加载速度快，编写简单</li></ul><p><strong>但是存在很大的缺陷，如可维护性差，不能根据 URL灵活多变 地显示内容等。</strong><br>因此，<strong>动态网页</strong>应运而生，它可以动态解析 URL中参数的变化，关联数据库并动态呈现不同的页面内容，非常灵活多变<br>现在遇到的大多数网站都是<strong>动态网站</strong>，它们不再是一个简单的 HTML，而是可能由 JSP、PHP、Python等语言编写的，其功能比静态网页强大和丰富太多了。 此外，<strong>动态网站还可以实现用户登录和注册的功能</strong>。 </p><h2 id="4-2-无状态-HTTP"><a href="#4-2-无状态-HTTP" class="headerlink" title="4.2 无状态 HTTP"></a>4.2 无状态 HTTP</h2><p>HTTP 特点之一 —— <strong>无状态</strong>。<br>HTTP 的无状态是指 <strong>HTTP 协议对事务处理是没有记忆能力的，也就是说服务器不知道客户端是什么状态</strong><br>意味着<strong>如果后续需要处理前面的信息</strong>，则<strong>必须重传</strong>，这也导致需要额外传递一些前面的重复请求，才能获取后续响应 </p><p><img src="/2022/04/28/python-pa-chong-bi-ji-04-session-yu-cookies/1651149099735.png" alt="Session和Cookies"></p><h2 id="4-3-Session"><a href="#4-3-Session" class="headerlink" title="4.3 Session"></a>4.3 Session</h2><p><strong>Session（会话）</strong></p><p>其本身的含义是指有始有终的一系列动作 / 消息。</p><p>比如，打电话时，从拿起电话拨号到挂断电话这中间的一系列过程可以称为一个 Session。<br>在 Web 中，Session对象用来存储特定用户 Session所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session对象中的变量将不会丢失，而是在整个用户 Session中一直存在下 去。当用户请求来自应用程序的 Web 页时，如果该用户还没有 Session，则 Web 服务器将自动创建一个 Session对象。当 Session过期或被放弃后，服务器将终止该 Session。 </p><h2 id="4-4-Cookies"><a href="#4-4-Cookies" class="headerlink" title="4.4 Cookies"></a>4.4 Cookies</h2><p><strong>Cookies</strong> </p><p>指某些网站为了辨别用户身份、进行 Session跟踪而存储在用户本地终端上的数据。 </p><h2 id="4-5-Session维持"><a href="#4-5-Session维持" class="headerlink" title="4.5 Session维持"></a>4.5 Session维持</h2><p><strong>当客户端第一次请求服务器时</strong><br>服务器会返回一个响应头中带有 <strong>Set-Cookie</strong> 字段的响应给客户端，用来标记是哪一个用户，客户端浏览器会把 Cookies 保存起来。<br><strong>当浏览器下一次再请求该网站时</strong><br>浏览器会把此 Cookies 放到请求头一起提交给服务器，Cookies 携带了 Session ID 信息，服务器检查该 Cookies 即可找到对应的 Session是什么，然后再判断 Session来以此来辨认用户状态。<br><strong>在成功登录某个网站时</strong><br>服务器会告诉客户端设置哪些 Cookies 信息，在后续访问页面时客户端会把 Cookies 发送给服务器，服务器再找到对应的 Session加以判断。如果 Session中的某些设置登录状态的变量是有效的，那就证明用户处于登录状态<br><strong>此时返回登录之后才可以查看的网页内容，浏览器再进行解析便可以看到了</strong><br>反之，如果传给服务器的 Cookies 是无效的，或者 Session已经过期了，我们将不能继续访问页面，此时可能会收到错误的响应或者跳转到登录页面重新登录</p><p>所以，Cookies 和 Session需要配合，一个处于客户端，一个处于服务端，二者共同协作，就实现了登录 Session控制。 </p><p><img src="/2022/04/28/python-pa-chong-bi-ji-04-session-yu-cookies/1651149541673.png" alt="Session和Cookies"></p><h2 id="4-6-Cookies属性结构"><a href="#4-6-Cookies属性结构" class="headerlink" title="4.6 Cookies属性结构"></a>4.6 Cookies属性结构</h2><p>接下来，我们来看看 Cookies 都有哪些内容。这里以知乎为例，在浏览器开发者工具中打开 Application选项卡，然后在左侧会有一个 Storage 部分，最后一项即为 Cookies，将其点开，如图所示，这些就是 Cookies。  </p><p><img src="/2022/04/28/python-pa-chong-bi-ji-04-session-yu-cookies/1651149651557.png" alt="Cookies属性结构"></p><ul><li><strong>Name</strong>，即该 Cookie 的名称。Cookie 一旦创建，名称便不可更改</li><li><strong>Value</strong>，即该 Cookie 的值。如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码</li><li><strong>MaxAge</strong>，即该 Cookie 失效的时间，单位秒，也常和 Expires 一起使用，通过它可以计算出其有效时间。<br>MaxAge 如果为正数，则该 Cookie 在 MaxAge 秒之后失效。<br>如果为负数，则关闭浏览器时 Cookie 即 失效，浏览器也不会以任何形式保存该 Cookie</li><li><strong>Path</strong>，即该 Cookie 的使用路径。<br>如果设置为 /path/，则只有路径为 /path/ 的页面可以访问该 Cookie。<br>如果设置为 /，则本域名下的所有页面都可以访问该 Cookie</li><li><strong>Domain</strong>，即可以访问该 Cookie 的域名。例如如果设置为 .zhihu.com，则所有以 zhihu.com，结尾的域名都可以访问该 Cookie</li><li><strong>Size</strong> 字段，即此 Cookie 的大小</li><li><strong>Http</strong> 字段，即 Cookie 的 httponly属性。若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie</li><li><strong>Secure</strong>，即该 Cookie 是否仅被使用安全协议传输。安全协议。安全协议有 HTTPS、SSL等，在网络上传输数据之前先将数据加密。默认为 false。</li></ul><h2 id="4-7-会话-Cookie-和持久-Cookie"><a href="#4-7-会话-Cookie-和持久-Cookie" class="headerlink" title="4.7 会话 Cookie 和持久 Cookie"></a>4.7 会话 Cookie 和持久 Cookie</h2><p><strong>表面意思来说</strong></p><p>会话 Cookie 就是把 Cookie 放在浏览器内存里，浏览器在关闭之后该 Cookie 即失效<br>持久 Cookie 则会保存到客户端的硬盘中，下次还可以继续使用，用于长久保持用户登录状态</p><p><strong>严格来说</strong></p><p><strong>没有会话 Cookie 和持久 Cookie 之分</strong>，只是由 Cookie 的 MaxAge 或 Expires 字段决定了过期的时间。<br>因此，一些持久化登录的网站其实就是把 Cookie 的有效时间和 Session有效期设置得比较长，下次我们再访问页面时仍然携带之前的 Cookie，就可以直接保持登录状态。</p><h2 id="4-8-常见误区"><a href="#4-8-常见误区" class="headerlink" title="4.8 常见误区"></a>4.8 常见误区</h2><p><strong>在谈论 Session机制的时候</strong></p><p>常常听到这样一种<strong>误解 ——“只要关闭浏览器，Session就消失了”</strong>。<br>对 Session 来说，除非程序通知服务器删除一个 Session，否则服务器会一直保留。<br>比如，程序一般都是在我们做注销操作时才去删除 Session。 但是当我们关闭浏览器时，浏览器不会主动在关闭之前通知服务器它将要关闭，所以服务器根本不会有机会知道浏览器已经关闭。<br>之所以会有这种错觉，是因为大部分网站都使用会话 Cookie 来保存 Session ID 信息，而关闭浏览器后 Cookies 就消失了，再次连接服务器时，也就无法找到原来的 Session了。如果服务器设置的 Cookies 保存到硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 Cookies 发送给服务器，则再次打开浏览器，仍然能够找到原来的 Session ID，依旧还是可以保持登录状态的。 </p><p>而且恰恰是由于关闭浏览器不会导致 Session被删除，这就需要服务器为 Session设置一个失效时间，当距离客户端上一次使用 Session的时间超过这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把 Session删除以节省存储空间 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记03-爬虫的基本原理</title>
      <link href="/2022/04/27/python-pa-chong-bi-ji-03-pa-chong-de-ji-ben-yuan-li/"/>
      <url>/2022/04/27/python-pa-chong-bi-ji-03-pa-chong-de-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="03-原理探究，了解爬虫的基本原理"><a href="#03-原理探究，了解爬虫的基本原理" class="headerlink" title="03-原理探究，了解爬虫的基本原理"></a>03-原理探究，了解爬虫的基本原理</h1><p>我们可以把互联网比作一张大网，而爬虫（即网络爬虫）便是在网上爬行的蜘蛛。如果把网的节点比作一个个网页，爬虫爬到这 就相当于访问了该页面，获取了其信息。可以把节点间的连线比作网页与网页之间的链接关系，这样蜘蛛通过一个节点后，可以顺着节点连线继续爬行到达下一个节点，即通过一个网页继续获取后续的网页，这样整个网的节点便可以被蜘蛛全部爬行到，网站的数据就可以被抓取下来了。  </p><h2 id="3-1-爬虫概述"><a href="#3-1-爬虫概述" class="headerlink" title="3.1 爬虫概述"></a>3.1 爬虫概述</h2><p> 简单来说，爬虫就是获取网页并提取和保存信息的自动化程序。</p><h2 id="3-2-获取网页"><a href="#3-2-获取网页" class="headerlink" title="3.2 获取网页"></a>3.2 获取网页</h2><p> 爬虫首先要做的工作就是 <strong>获取网页</strong>，这里就是获取网页的源代码。</p><p> <strong>源代码里包含了网页的部分有用信息，所以只要把源代码获取下来，就可以从中提取想要的信息了。</strong> 前面讲了请求和响应的概念，向网站的服务器发送一个请求，返回的响应体便是网页源代码。</p><p>所以，最关键的部分就是<strong>构造一个请求并发送给服务器</strong>，然后<strong>接收到响应并将其解析出来</strong>，那么这个流程怎样实现呢？总不能手工去截取网页源码吧？ </p><p>不用担心，Python提供了许多库来帮助我们实现这个操作，如 <strong>urllib、requests</strong> 等。我们可以用这些库来帮助我们实现 HTTP 请求操作，请求和响应都可以用类库提供的数据结构来表示，得到响应之后只需要解析数据结构中的 Body部分即可，即得到网页的源代码，这样我们可以用程序来实现获取网页的过程了。  </p><h2 id="3-3-提取信息"><a href="#3-3-提取信息" class="headerlink" title="3.3 提取信息"></a>3.3 提取信息</h2><p>获取网页源代码后，接下来就是<strong>分析网页源代码</strong>，从中<strong>提取想要的数据</strong>。</p><p>首先，<strong>最通用的方法</strong>便是<strong>采用正则表达式提取</strong>，这是一个万能的方法，但是<strong>在构造正则表达式时比较复杂且容易出错</strong>。<br>另外，由于网页的结构有一定的规则，所以还有一些<strong>根据网页节点属性</strong>、<strong>CSS 选择器</strong>或 XPath来提取网页信息的库，<br>如 <strong>Beautiful Soup、pyquery、lxml</strong>等。</p><p>使用这些库，我们可以高效快速地从中提取网页信息，如节点的属性、文本值等。<br>提取信息是爬虫非常重要的部分，它可以使杂乱的数据变得条理清晰，以便我们后续处理和分析数据。  </p><h2 id="3-4-保存数据"><a href="#3-4-保存数据" class="headerlink" title="3.4 保存数据"></a>3.4 保存数据</h2><p>提取信息后，我们一般会将提取到的数据保存到某处以便后续使用。<br>这里保存形式有多种多样，如可以<strong>简单保存为 TXT文本或 JSON 文本</strong>，<br>也可以<strong>保存到数据库</strong>，如 <strong>MySQL和 MongoDB</strong> 等，<br>还可<strong>保存至远程服务器</strong>，如借助 SFTP 进行操作等。 </p><h2 id="3-5-自动化程序"><a href="#3-5-自动化程序" class="headerlink" title="3.5 自动化程序"></a>3.5 自动化程序</h2><p>手工可以提取这些信息，但是当量特别大或者想快速获取大量数据的话，就要借助程序。<br><strong>爬虫</strong>就是代替我们来完成这份爬取工作的自动化程序，<br>它<strong>可以在抓取过程中进行各种异常处理、错误重试等操作，确保爬取持续高效地运行</strong>。 </p><h2 id="3-6-能抓怎样的数据"><a href="#3-6-能抓怎样的数据" class="headerlink" title="3.6 能抓怎样的数据"></a>3.6 能抓怎样的数据</h2><p>在网页中我们能看到各种各样的信息，最常见的便是<strong>常规网页</strong>，<br>它们<strong>对应着 HTML代码</strong>，而<strong>最常抓取的便是 HTML源代码</strong>。<br><strong>有些网页返回的不是 HTML代码，而是一个 JSON 字符串</strong>（其中 <strong>API 接口大多采用这样的形式</strong>），<br>这种格式的数据方 便传输和解析，它们同样可以抓取，而且数据提取更加方便。<br>网页中还会看到看到各种二进制数据，如图片、视频和音频等。<br>利用爬虫，我们可以将这些二进制数据抓取下来，然后保存成 对应的文件名。<br>还有各种扩展名的文件，如 CSS、JavaScript 和配置文件等，<br>这些其实也是最普通的文件，<strong>只要在浏览器里面可以访问到，就可以将其抓取下来</strong>。 </p><p>上述内容其实都<strong>对应各自的 URL</strong>，是<strong>基于 HTTP 或 HTTPS 协议</strong>的，只要是这种数据，<strong>爬虫都可以抓取</strong>。  </p><h2 id="3-7-JavaScript-渲染页面"><a href="#3-7-JavaScript-渲染页面" class="headerlink" title="3.7 JavaScript 渲染页面"></a>3.7 JavaScript 渲染页面</h2><p>有时候，用 urllib 或 requests 抓取网页时，<strong>得到的源代码实际和浏览器中看到的不一样</strong>。<br>现在网页越来越多地采用 Ajax、前端模块化工具来构建，<br>整个网页可能都是由 JavaScript 渲染出来的，<br>也就是说<strong>原始的 HTML代码就是一个空壳</strong>，</p><p>例如： </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>This is a Demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>app.js<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在浏览器中打开这个页面时</p><ul><li>首先会加载这个 HTML内容</li><li>接着浏览器会发现其中引入了一个 app.js 文件</li><li>然后便会接着去请求这个文件，获取到该文件后，便会执行其中的 JavaScript 代码</li><li>而 JavaScript 则会改变 HTML中的节点，向其添加内容</li><li>最后得到 完整的页面。</li></ul><p>因此，使用基本 HTTP 请求库得到的源代码可能跟浏览器中的页面源代码不太一样。<br>对于这样的情况，<strong>可以分析其后台 Ajax 接口，也可使用 Selenium、Splash这样的库来实现模拟 JavaScript 渲染</strong>。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记02-Web网页基础</title>
      <link href="/2022/04/27/python-pa-chong-bi-ji-02-web-wang-ye-ji-chu/"/>
      <url>/2022/04/27/python-pa-chong-bi-ji-02-web-wang-ye-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="02：夯实基础，Web网页基础"><a href="#02：夯实基础，Web网页基础" class="headerlink" title="02：夯实基础，Web网页基础"></a>02：夯实基础，Web网页基础</h1><h2 id="2-1-网页的组成"><a href="#2-1-网页的组成" class="headerlink" title="2.1 网页的组成"></a>2.1 网页的组成</h2><p>网页可以分为三大部分： <strong>HTML、CSS、JavaScript</strong></p><ul><li><strong>HTML</strong>相当于骨架</li><li><strong>JavaScript</strong>相当于肌肉</li><li><strong>CSS</strong>相当于皮肤</li></ul><h3 id="2-1-1-HTML"><a href="#2-1-1-HTML" class="headerlink" title="2.1.1 HTML"></a>2.1.1 HTML</h3><p><strong>HTML</strong>是用来描述网页的一种语言<br>全称 Hyper Text Markup Language <strong>超文本标记语言</strong></p><p><strong>不同类型的元素通过不同类型的标签来表示：</strong></p><ul><li>图片用 img 标签表示</li><li>视频用 video 标签表示</li><li>段落用 p 标签标识</li><li>它们之间的布局又常通过布局标签 div 嵌套组合而成</li></ul><p><img src="/2022/04/27/python-pa-chong-bi-ji-02-web-wang-ye-ji-chu/1651049540474.png" alt="标签示例"></p><h3 id="2-1-2-CSS"><a href="#2-1-2-CSS" class="headerlink" title="2.1.2 CSS"></a>2.1.2 CSS</h3><p> 虽然 HTML定义了网页的结构，但是只有 HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里就需要借助 CSS 了。 </p><p> <strong>CSS</strong>，全称叫作 Cascading Style Sheets，即<strong>层叠样式表</strong>。<br>“<strong>层叠</strong>”是指当在 HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。<br>“<strong>样式</strong>”指网页中文字大小、颜色、元素间距、排列等 格式。<br><strong>CSS</strong> 是目前唯一的网页页面排版样式标准，有了它的帮助，页面才会变得更为美观。 </p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">#head_wrapper.s-ps-islite .s-p-top</span> <span class="token punctuation">{</span><span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span><span class="token property">bottom</span><span class="token punctuation">:</span> 40px<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span> 181px<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 这就是一个 CSS 样式。大括号前面是一个 CSS 选择器。此选择器的作用是首先选中 id 为 head_wrapper 且 class 为 s-ps-islite 的节点，然后再选中其内部的 class 为 s-p-top 的节点。<br>大括号内部写的就是一条条样式规则，例如 position指定了这个元素的布局方式为绝对布局，bottom指定元素的下边距为 40 像素，width指定了宽度为 100% 占满父元素，height 则指定了元素的高度。<br>也就是说，我们将位置、宽度、高度等样式配置统一写成这样的形式，然后用大括号括起来，接着在开头再加上 CSS 选择器，这就代表这个样式对 CSS 选择器选中的元素生效，元素就会根据此样式来展示 了。<br>在<strong>网页</strong>中，一般会统一定义整个网页的样式规则，并写入 CSS 文件中（其后缀为 css）。<br>在 <strong>HTML</strong>中，只需要用 link 标签即可引入写好的 CSS 文件，这样整个页面就会变得美观、优雅。  </p><h3 id="2-1-3-JavaScript"><a href="#2-1-3-JavaScript" class="headerlink" title="2.1.3 JavaScript"></a>2.1.3 JavaScript</h3><p><strong>JavaScript</strong>，简称 JS，是一种<strong>脚本语言</strong>。 </p><p>在网页里可能会看到一些<strong>交互和动画效果</strong><br>如下载进度条、提示框、轮播图等，这通常就是利用 <strong>JavaScript</strong> </p><p><strong>JavaScript <strong>使得用户与信息之间不只是一种浏览与显示的关系，<br>而是实现了一种</strong>实时、动态、交互</strong>的页面功能。 </p><p>JavaScript <strong>通常也是以单独的文件形式加载</strong>的，后缀为 js，在 HTML中通过 script 标签即可引入 </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"jquery-2.1.0.js"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>HTML</strong>定义了网页的内容和结构</li><li><strong>CSS</strong> 描述了网页的布局</li><li><strong>JavaScript</strong> 定义了网页的行为</li></ul><h2 id="2-2-网页的结构"><a href="#2-2-网页的结构" class="headerlink" title="2.2 网页的结构"></a>2.2 网页的结构</h2><p>了解了网页的基本组成，我们再用一个例子来感受下 HTML的基本结构。新建一个文本文件，名称可以自取，后缀为 html，内容如下： </p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>This is a Demo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>wrapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>Hello, this is a paragraph.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>head 标签内定义一些页面的配置和引用</li><li>title 标签则定义网页的标题，会显示在网页的选项卡中，不会显示在正文中</li><li>body 标签内是在网页正文中显示的内容</li><li>div 标签定义网页中的区块</li><li>h2 标签代表一个二级标题</li><li>p 标签代表一个段落</li></ul><p>代码保存后，在浏览器中打开该文件，如图所示</p><p><img src="/2022/04/27/python-pa-chong-bi-ji-02-web-wang-ye-ji-chu/1651050885436.png" alt="test.html示例"></p><p><strong>一个网页的标准形式：</strong></p><ul><li><strong>html</strong> 标签内嵌套 head 和 body 标签</li><li><strong>head</strong> 内定义网页的配置和引用</li><li><strong>body</strong> 内定义网页的正文</li></ul><h2 id="2-3-节点树及节点间的关系"><a href="#2-3-节点树及节点间的关系" class="headerlink" title="2.3 节点树及节点间的关系"></a>2.3 节点树及节点间的关系</h2><p>在 HTML 中，<strong>所有标签定义的内容都是节点</strong>，它们构成了一个 HTML DOM 树</p><p><strong>DOM</strong> 是 W3C（万维网联盟）的标准，其英文全称 Document Object Model， 即<strong>文档对象模型</strong></p><table><thead><tr><th><strong>访问 HTML 和 XML 文档的标准</strong></th></tr></thead><tbody><tr><td>W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</td></tr></tbody></table><p> W3C DOM 标准被分为 3 个不同的部分：</p><ul><li>核心 DOM- 针对任何结构化文档的标准模型</li><li>XMLDOM- 针对 XML文档的标准模型</li><li>HTMLDOM- 针对 HTML文档的标准模型</li></ul><p> 根据 W3C 的 HTMLDOM 标准<br><strong>HTML文档中的所有内容都是节点：</strong> </p><ul><li>整个文档是一个<strong>文档节点</strong></li><li>每个 HTML元素是<strong>元素节点</strong></li><li>HTML元素内的文本是<strong>文本节点</strong></li><li>每个 HTML属性是<strong>属性节点</strong></li><li>注释是<strong>注释节点</strong></li></ul><p> HTMLDOM 将 HTML文档视作树结构，这种结构被称为<strong>节点树</strong>，如图所示：</p><p><img src="/2022/04/27/python-pa-chong-bi-ji-02-web-wang-ye-ji-chu/1651051647323.png" alt="节点树"></p><p> 通过 HTMLDOM，树中的所有节点均可通过 JavaScript 访问，所有 HTML节点元素均可被修改，也可以被创建或删除。 </p><p><strong>节点树中的节点彼此拥有层级关系</strong>。<br>常用父（parent）、子（child）和兄弟（sibling）等术语描述这些关系。<br>父节点拥有子节点，同级的子节点被称为兄弟节点。<br>顶端节点称为<strong>根（root）</strong>。<br>除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。<br>本段参考 W3SCHOOL，链接：<a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp">http://www.w3school.com.cn/htmldom/dom_nodes.asp</a> 。 </p><h2 id="2-4-选择器"><a href="#2-4-选择器" class="headerlink" title="2.4 选择器"></a>2.4 选择器</h2><p>在 CSS 中，使用 <strong>CSS 选择器</strong>来定位节点</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示为 <strong>#container</strong></p><p>其中 <strong># 开头代表选择 id</strong> ，其后紧跟 id 的名称</p><p>如果想选择 class 为 wrapper 的节点<br>可使用 <strong>.wrapper</strong><br>以点 “ . ” 开头代表选择 class，其后紧跟 class 的名称</p><p>也可使用<strong>根据标签名筛选</strong><br>例如想选择二级标题，直接用 h2 即可</p><table><thead><tr><th>最常用的 3 种表示</th></tr></thead><tbody><tr><td>根据 <strong>id、class、标签名</strong> 筛选</td></tr></tbody></table><p> CSS 选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表<strong>嵌套关系</strong>，<br>如 <strong>#container .wrapper p</strong> </p><ul><li>代表先选择 id 为 container 的节点</li><li>然后选中其内部的 class 为 wrapper 的节点</li><li>然后再进一步 选中其内部的 p 节点。</li></ul><p>不加空格，则代表 <strong>并列关系</strong><br>如  <strong>div#container .wrapper p.text</strong> </p><ul><li>代表先选择 id 为 container 的 div节点</li><li>然后选中其内部的 class 为 wrapper 的节点</li><li>再进一步选中其内部的 class 为 text 的 p 节点。</li></ul><table><thead><tr><th>选择器</th><th>例子</th><th>例子描述</th></tr></thead><tbody><tr><td>.class</td><td>.intro</td><td>选择 class=”intro” 的所有节点</td></tr><tr><td>#id</td><td>#firstname</td><td>选择 id=”firstname” 的所有节点</td></tr><tr><td>*</td><td>*</td><td>选择所有节点</td></tr><tr><td>element</td><td>p</td><td>选择所有 p 节点</td></tr><tr><td>element,element</td><td>div,p</td><td>选择所有 div 节点和所有 p 节点</td></tr><tr><td>element element</td><td>div p</td><td>选择 div 节点内部的所有 p 节点</td></tr><tr><td>element&gt;element</td><td>div&gt;p</td><td>选择父节点为 div 节点的所有 p 节点</td></tr><tr><td>element+element</td><td>div+p</td><td>选择紧接在 div 节点之后的所有 p 节点</td></tr><tr><td>[attribute]</td><td>[target]</td><td>选择带有 target 属性的所有节点</td></tr><tr><td>[attribute=value]</td><td>[target=blank]</td><td>选择 target=”blank” 的所有节点</td></tr><tr><td>[attribute~=value]</td><td>[title~=flower]</td><td>选择 title 属性包含单词 flower 的所有节点</td></tr><tr><td>:link</td><td>a:link</td><td>选择所有未被访问的链接</td></tr><tr><td>:visited</td><td>a:visited</td><td>选择所有已被访问的链接</td></tr><tr><td>:active</td><td>a:active</td><td>选择活动链接</td></tr><tr><td>:hover</td><td>a:hover</td><td>选择鼠标指针位于其上的链接</td></tr><tr><td>:focus</td><td>input:focus</td><td>选择获得焦点的 input 节点</td></tr><tr><td>:first-letter</td><td>p:first-letter</td><td>选择每个 p 节点的首字母</td></tr><tr><td>:first-line</td><td>p:first-line</td><td>选择每个 p 节点的首行</td></tr><tr><td>:first-child</td><td>p:first-child</td><td>选择属于父节点的第一个子节点的所有 p 节点</td></tr><tr><td>:before</td><td>p:before</td><td>在每个 p 节点的内容之前插入内容</td></tr><tr><td>:after</td><td>p:after</td><td>在每个 p 节点的内容之后插入内容</td></tr><tr><td>:lang(language)</td><td>p:lang</td><td>选择带有以 it 开头的 lang 属性值的所有 p 节点</td></tr><tr><td>element1~element2</td><td>p~ul</td><td>选择前面有 p 节点的所有 ul 节点</td></tr><tr><td>[attribute^=value]</td><td>a[src^=”https”]</td><td>选择其 src 属性值以 https 开头的所有 a 节点</td></tr><tr><td>[attribute$=value]</td><td>a[src$=”.pdf”]</td><td>选择其 src 属性以.pdf 结尾的所有 a 节点</td></tr><tr><td>[attribute*=value]</td><td>a[src*=”abc”]</td><td>选择其 src 属性中包含 abc 子串的所有 a 节点</td></tr><tr><td>:first-of-type</td><td>p:first-of-type</td><td>选择属于其父节点的首个 p 节点的所有 p 节点</td></tr><tr><td>:last-of-type</td><td>p:last-of-type</td><td>选择属于其父节点的最后 p 节点的所有 p 节点</td></tr><tr><td>:only-of-type</td><td>p:only-of-type</td><td>选择属于其父节点唯一的 p 节点的所有 p 节点</td></tr><tr><td>:only-child</td><td>p:only-child</td><td>选择属于其父节点的唯一子节点的所有 p 节点</td></tr><tr><td>:nth-child(n)</td><td>p:nth-child</td><td>选择属于其父节点的第二个子节点的所有 p 节点</td></tr><tr><td>:nth-last-child(n)</td><td>p:nth-last-child</td><td>同上，从最后一个子节点开始计数</td></tr><tr><td>:nth-of-type(n)</td><td>p:nth-of-type</td><td>选择属于其父节点第二个 p 节点的所有 p 节点</td></tr><tr><td>:nth-last-of-type(n)</td><td>p:nth-last-of-type</td><td>同上，但是从最后一个子节点开始计数</td></tr><tr><td>:last-child</td><td>p:last-child</td><td>选择属于其父节点最后一个子节点的所有 p 节点</td></tr><tr><td>:root</td><td>:root</td><td>选择文档的根节点</td></tr><tr><td>:empty</td><td>p:empty</td><td>选择没有子节点的所有 p 节点（包括文本节点）</td></tr><tr><td>:target</td><td>#news:target</td><td>选择当前活动的 #news 节点</td></tr><tr><td>:enabled</td><td>input:enabled</td><td>选择每个启用的 input 节点</td></tr><tr><td>:disabled</td><td>input:disabled</td><td>选择每个禁用的 input 节点</td></tr><tr><td>:checked</td><td>input:checked</td><td>选择每个被选中的 input 节点</td></tr><tr><td>:not(selector)</td><td>:not</td><td>选择非 p 节点的所有节点</td></tr><tr><td>::selection</td><td>::selection</td><td>选择被用户选取的节点部分</td></tr></tbody></table><p> 另外，还有一种比较常用的选择器是 <strong>XPath</strong>，这种选择方式后面会详细介绍。 </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬虫笔记01-HTTP基本原理</title>
      <link href="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/"/>
      <url>/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="01-必知必会，掌握HTTP基本原理"><a href="#01-必知必会，掌握HTTP基本原理" class="headerlink" title="01:必知必会，掌握HTTP基本原理"></a>01:必知必会，掌握HTTP基本原理</h1><h2 id="1-1-URI-和-URL"><a href="#1-1-URI-和-URL" class="headerlink" title="1.1 URI 和 URL"></a>1.1 URI 和 URL</h2><p><strong>URI</strong> 的全称为 Uniform Resource Identifier，即统一资源标志符，<br><strong>URL</strong>的全称为 Universal Resource Locator，即统一资源定位符。<br>举例来说，<a href="https://github.com/favicon.ico">https://github.com/favicon.ico</a> ，它是一个 URL，也是一个 URI。即有这样的一个图标资源，我们用 URL/URI 来唯一指定了它的访问方式，这其中包括了访问协议 HTTPS、访问路径（即根目录）和资源名称 favicon.ico。通过这样一个链接，我们便可以从互联网上找到这个资源，这就是 URL/URI。</p><h3 id="URI-和-URL-的关系"><a href="#URI-和-URL-的关系" class="headerlink" title="URI 和 URL 的关系"></a>URI 和 URL 的关系</h3><p>URL是 URI 的子集，也就是说每个 URL都是 URI，但不是每个 URI 都是 URL。那么，什么样的 URI 不是 URL呢？URI 还包括一个子类叫作 <strong>URN</strong>，它的全称为 Universal Resource Name，即统一资源名称。<br>URN 只命名资源而不指定如何定位资源，比如 urn:isbn:0451450523 指定了一本书的 ISBN，可以唯一标识这本书，但是没有指定到哪里定位这本书，这就是 URN。URL、URN 和 URI 的关系可以用图表示。<br>但是在目前的互联网，URN 的使用非常少，几乎所有的 URI 都是 URL，所以一般的网页链接我们可以称之为 URL，也可以称之为 URI，我个人习惯称之为 URL。</p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651034197460.png" alt="URI与URL和URN的关系"></p><h2 id="1-2-超文本"><a href="#1-2-超文本" class="headerlink" title="1.2 超文本"></a>1.2 超文本</h2><p><strong>超文本</strong> （Hypertext）<br>浏览器里看到的网页就是超文本解析而成的，其网页源代码是一系列 HTML 代码，里面包含了一系列标签<br>比如：</p><ul><li>img 显示图片</li><li>p 指定显示段落等</li></ul><p>浏览器解析这些标签后，便形成了我们平常看到的网页，而<strong>网页的源代码 HTML 就可以称作超文本</strong></p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651035846819.png" alt="网页源代码HTML"></p><h2 id="1-3-HTTP-和HTTPS"><a href="#1-3-HTTP-和HTTPS" class="headerlink" title="1.3 HTTP 和HTTPS"></a>1.3 HTTP 和HTTPS</h2><p><a href="https://www.taobao.com/">https://www.taobao.com/</a> 中，URL 的开头会有 http 或 https<br>这个就是访问资源需要的协议类型，又是还会看到 ftp、sftp、smb 开头的URL<br><strong>ftp、sftp、smb</strong> 都是指的<strong>协议类型</strong></p><h3 id="HTTP-（Hyper-Text-Transfer-Protocol）超文本传输协议"><a href="#HTTP-（Hyper-Text-Transfer-Protocol）超文本传输协议" class="headerlink" title="HTTP （Hyper Text Transfer Protocol）超文本传输协议"></a>HTTP （Hyper Text Transfer Protocol）超文本传输协议</h3><p>用于从网络传输文本数据到本地浏览器的传送协议，<strong>能保证高效而准确地传送超文本文档</strong><br>由万维网协会（World Wide Web Consortium）和 Internet 工作小组 IETF（Internet Engineering Task Force）共同合作制定的规范<br>目前广泛使用的是 HTTP1.1 版本</p><h3 id="HTTPS-（Hyper-Text-Transfer-Protocol-over-Secure-Socket-Layer）"><a href="#HTTPS-（Hyper-Text-Transfer-Protocol-over-Secure-Socket-Layer）" class="headerlink" title="HTTPS （Hyper Text Transfer Protocol over Secure Socket Layer）"></a>HTTPS （Hyper Text Transfer Protocol over Secure Socket Layer）</h3><p>是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，简称为 HTTPS，安全基础是SSL，因此通过它传输的内容都是经过<strong>SSL加密</strong><br>主要作用可以分为两种：</p><ul><li>建立一个信息安全通道，来保证数据传输的安全</li><li>确认网站的真实性，凡是使用了 HTTPS 的网站，都可以通过点击浏览器地址栏的锁头标志来查看网站认证之后的真实信息，也可以通过 CA 机构颁发的安全签章来查询</li></ul><p><strong>越来越多的网站和 App 都已经开始向 HTTPS 方向发展</strong>（大势所趋）<br>例如：</p><ul><li>苹果公司强制所有 iOS App 在 2017 年 1 月 1 日 前全部改为使用 HTTPS 加密，否则 App 就无法在应用商店上架。 </li><li>谷歌从 2017 年 1 月推出的 Chrome 56 开始，对未进行 HTTPS 加密的网址链接亮出风险提示，即在地址栏的显著位置提醒用户 “此网页不安全”。 </li><li>腾讯微信小程序的官方需求文档要求后台使用 HTTPS 请求进行网络通信，不满足条件的域名和协议无法请求。</li></ul><h2 id="1-4-HTTP-请求过程"><a href="#1-4-HTTP-请求过程" class="headerlink" title="1.4 HTTP 请求过程"></a>1.4 HTTP 请求过程</h2> <center>在浏览器中输入一个 URL，回车之后便可以在浏览器中观察到页面内容</center><center>这个过程是浏览器向网站所在的服务器发送了一个请求</center><center>网站服务器接收到这个请求后进行处理和解析，然后返回对应的响应，接着传回给浏览器。</center>响应里包含了页面的源代码等内容，浏览器再对其进行解析，便将网页呈现了出来，传输模型如图所示 ：<p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651037054231.png" alt="HTTP请求传输模型"></p><p>打开 Chrome 浏览器，右击并选择“检查”项即可打开浏览器的开发者工具</p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651037332132.png" alt="浏览器开发者工具"></p><p> 我们先观察第一个网络请求，即 <a href="http://www.baidu.com,其中各列的含义如下./">www.baidu.com，其中各列的含义如下。</a> </p><ul><li>第一列 <strong>Name</strong>：请求的名称，一般会将 URL的最后一部分内容当作名称。 </li><li>第二列 <strong>Status</strong>：响应的状态码，这里显示为 200，代表响应是正常的。通过状态码，我们可以判断发送了请求之后是否得到了正常的响应。  </li><li>第三列 <strong>Type</strong>：请求的文档类型。这里为 document，代表我们这次请求的是一个 HTML文档，内容就是一些 HTML代码。 </li><li>第四列 <strong>Initiator</strong>：请求源。用来标记请求是由哪个对象或进程发起的。 </li><li>第五列 <strong>Size</strong>：从服务器下载的文件和请求的资源大小。如果是从缓存中取得的资源，则该列会显示 fromcache。 </li><li>第六列 <strong>Time</strong>：发起请求到获取响应所用的总时间。 </li><li>第七列 <strong>Waterfall</strong>：网络请求的可视化瀑布流。</li></ul><p> 我们点击这个条目即可看到其更详细的信息，如图所示。  </p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651037663851.png" alt="HTTP请求的详细信息"></p><p> 首先是 General部分，Request URL为请求的 URL，Request Method 为请求的方法，Status Code 为响应状态码，Remote Address 为远程服务器的地址和端口，Referrer Policy为 Referrer 判别策略。 再继续往下，可以看到，有 Response Headers 和 Request Headers，这分别代表响应头和请求头。请求头里带有许多请求信息，例如浏览器标识、Cookies、Host 等信息，这是请求的一部分，服务器会根据请求头 内的信息判断请求是否合法，进而作出对应的响应。图中看到的 Response Headers 就是响应的一部分，例如其中包含了服务器的类型、文档类型、日期等信息，浏览器接受到响应后，会解析响应内容，进而呈 现网页内容。<br>下面我们分别来介绍一下请求和响应都包含哪些内容。 </p><h2 id="1-5-请求"><a href="#1-5-请求" class="headerlink" title="1.5 请求"></a>1.5 请求</h2><p> 请求，由客户端向服务端发出，可以分为 4 部分内容：请求方法（Request Method）、请求的网址（Request URL）、请求头（Request Headers）、请求体（Request Body）。 </p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651038019586.png" alt="请求的4部分内容"></p><h4 id="1-5-1-请求方法"><a href="#1-5-1-请求方法" class="headerlink" title="1.5.1 请求方法"></a>1.5.1 请求方法</h4><p>常见的请求方法有两种： GET 和 POST</p><ol><li>在浏览器中直接输入 URL 并回车，便发起了一个 <strong>GET</strong> 请求，请求的参数会直接包含到 URL 里<br> 例如，在百度中搜索 Python，这就是一个 GET请求，链接为 <a href="https://www.baidu.com/s?wd=Python%EF%BC%8C%E5%85%B6%E4%B8%AD">https://www.baidu.com/s?wd=Python，其中</a> URL中包 含了请求的参数信息，这里参数 wd 表示要搜寻的关键字。</li><li><strong>POST</strong>请求大多在表单提交时发起。<br>   比如，对于一个登录表单，输入用户名和密码后，点击 “登录”按钮，这通常会发起一个 POST请求，其数据通常 以表单的形式传输，而不会体现在 URL中。</li></ol><p> GET和 POST请求方法有如下<strong>区别</strong>。  </p><ul><li><strong>GET</strong>请求中的参数包含在 URL里面，数据可以在 URL中看到，而 <strong>POST</strong>请求的 URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。 </li><li><strong>GET</strong>请求提交的数据最多只有 1024 字节，而 <strong>POST</strong>请求没有限制。</li></ul><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651038392653.png" alt="请求方法描述表格"></p><h4 id="1-5-2-请求的网址"><a href="#1-5-2-请求的网址" class="headerlink" title="1.5.2 请求的网址"></a>1.5.2 请求的网址</h4><p> 请求的网址，即统一资源定位符 URL，它可以唯一确定我们想请求的资源。 </p><h4 id="1-5-3-请求头"><a href="#1-5-3-请求头" class="headerlink" title="1.5.3 请求头"></a>1.5.3 请求头</h4><p> 请求头，用来说明服务器要使用的附加信息，比较重要的信息有 <strong>Cookie、Referer、User-Agent</strong> 等。下面简要说明一些常用的头信息。 </p><ul><li><strong>Accept</strong>：请求报头域，用于指定客户端可接受哪些类型的信息。 </li><li><strong>Accept-Language</strong>：指定客户端可接受的语言类型。 </li><li><strong>Accept-Encoding</strong>：指定客户端可接受的内容编码。 </li><li><strong>Host</strong>：用于指定请求资源的主机 IP 和端口号，其内容为请求 URL的原始服务器或网关的位置。从 HTTP 1.1 版本开始，请求必须包含此内容。  </li><li><strong>Cookie</strong>：也常用复数形式 <strong>Cookies</strong>，这是网站为了辨别用户进行会话跟踪而存储在用户本地的数据。它的<strong>主要功能是维持当前访问会话</strong>。例如，我们输入用户名和密码成功登录某个网站后，服务器会用会话保存登录状态信息，后面我们每次刷新或请求该站点的其他页面时，会发现都是登录状态，这就是 Cookies 的功劳。<br>  Cookies 里有信息标识了我们所对应的服务器的会话，每次浏览器在请求该站点的页面时，都会在请求头中加上 Cookies 并将其发送给服务器，服务器通过 Cookies 识别出是我们自己，并且查出当前状态是登录状态，所以返回结果就是登录之后才能看到的网页内容。 </li><li><strong>Referer</strong>：此内容用来标识这个请求是从哪个页面发过来的，服务器可以拿到这一信息并做相应的处理，如做<strong>来源统计、防盗链处理</strong>等。  </li><li><strong>User-Agent</strong>：简称 UA，它是一个特殊的字符串头，可以使服务器识别客户使用的操作系统及版本、浏览器及版本等信息。在做爬虫时加上此信息，可以<strong>伪装为浏览器</strong>；如果不加，很可能会被识别出为爬虫。 </li><li><strong>Content-Type</strong>：也叫<strong>互联网媒体类型（Internet Media Type）或者 MIME类型</strong>，在 HTTP 协议消息头中，它用来表示具体请求中的媒体类型信息。例如，text/html代表 HTML格式，image/gif代表 GIF 图 片，application/json代表 JSON 类型，更多对应关系可以查看此对照表：<a href="http://tool.oschina.net/commons%E3%80%82">http://tool.oschina.net/commons。</a></li></ul><h4 id="1-5-4-请求体"><a href="#1-5-4-请求体" class="headerlink" title="1.5.4 请求体"></a>1.5.4 请求体</h4><p> 请求体一般承载的内容是 POST请求中的表单数据，而对于 GET请求，请求体则为空。  </p><p> 例如，这里我登录 GitHub 时捕获到的请求和响应如图所示。 </p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651038827967.png" alt="登录GitHub的请求和响应"></p><p> 登录之前，我们填写了用户名和密码信息，提交时这些内容就会以表单数据的形式提交给服务器，<strong>此时需要注意 Request Headers 中指定 Content-Type 为 application/x-www-form-urlencoded。只有设置 Content-Type 为 application/x-www-form-urlencoded，才会以表单数据的形式提交</strong>。另外，我们也可以将 Content-Type 设置为 application/json来提交 JSON 数据，或者设置为 multipart/form-data 来上传文件。</p><p> 表格中列出了 Content-Type 和 POST提交数据方式的关系。  </p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651038945038.png" alt="Content-Type和POST提交数据方式"></p><h2 id="1-6-响应"><a href="#1-6-响应" class="headerlink" title="1.6 响应"></a>1.6 响应</h2><p> <strong>由服务端返回给客户端，可以分为三部分</strong>：</p><ol><li>响应状态码（Response Status Code）</li><li>响应头（Response Headers）</li><li>响应体（Response Body）</li></ol><h4 id="1-6-1-响应状态码"><a href="#1-6-1-响应状态码" class="headerlink" title="1.6.1 响应状态码"></a>1.6.1 响应状态码</h4><p> <strong>响应状态码表示服务器的响应状态</strong> </p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651039214371.png" alt="响应状态码01"></p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651039235649.png" alt="响应状态码02"></p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651039258631.png" alt="响应状态码03"></p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651039278881.png" alt="响应状态码04"></p><h4 id="1-6-2-响应头"><a href="#1-6-2-响应头" class="headerlink" title="1.6.2 响应头"></a>1.6.2 响应头</h4><p> 响应头包含了服务器对请求的应答信息，如 Content-Type、Server、Set-Cookie 等。下面简要说明一些常用的响应头信息。 </p><ul><li><strong>Date</strong>：标识响应产生的时间。 </li><li><strong>Last-Modified</strong>：指定资源的最后修改时间。 </li><li><strong>Content-Encoding</strong>：指定响应内容的编码。 </li><li><strong>Server</strong>：包含服务器的信息，比如名称、版本号等。 </li><li><strong>Content-Type</strong>：文档类型，指定返回的数据类型是什么，如 text/html代表返回 HTML文档，application/x-javascript 则代表返回 JavaScript 文件，image/jpeg则代表返回图片。 </li><li><strong>Set-Cookie</strong>：设置 Cookies。响应头中的 Set-Cookie 告诉浏览器需要将此内容放在 Cookies 中，下次请求携带 Cookies 请求。 </li><li><strong>Expires</strong>：指定响应的过期时间，可以使代理服务器或浏览器将加载的内容更新到缓存中。如果再次访问时，就可以直接从缓存中加载，降低服务器负载，缩短加载时间。</li></ul><h4 id="1-6-3-响应体"><a href="#1-6-3-响应体" class="headerlink" title="1.6.3 响应体"></a>1.6.3 响应体</h4><p> 最重要的当属<strong>响应体</strong>的内容了。响应的正文数据都在响应体中，<br>比如：</p><ul><li>请求网页时，它的响应体就是网页的 HTML代码；</li><li>请求一张图片时，它的响应体就是图片的二进制数据。</li></ul><p>我们做爬虫请求网页后，要解析的 内容就是响应体，如图所示。  </p><p><img src="/2022/04/27/python-pa-chong-bi-ji-01-http-ji-ben-yuan-li/1651039618032.png" alt="响应体"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo常用命令</title>
      <link href="/2022/04/26/hexo-chang-yong-ming-ling/"/>
      <url>/2022/04/26/hexo-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo init <span class="token punctuation">[</span>folder<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"post title with whitespace"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page --path about/me <span class="token string">"About me"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>"About me"</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page --path about/me<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>"page"</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo g<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo publish <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>filename<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo render <span class="token operator">&lt;</span>file<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo migrate <span class="token operator">&lt;</span>type<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo list <span class="token operator">&lt;</span>type<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示 Hexo 版本。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><h3 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo --safe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。</p><h3 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo --silent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>隐藏终端信息。</p><h3 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 custom.yml 代替默认的 _config.yml</span>$ hexo server --config custom.yml<span class="token comment"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span>$ hexo generate --config custom.yml,custom2.json,custom3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>自定义配置文件的路径，指定这个参数后将不再使用默认的 <code>_config.yml</code>。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 custom.yml 代替默认的 _config.yml</span>$ hexo server --config custom.yml<span class="token comment"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span>$ hexo generate --config custom.yml,custom2.json,custom3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h3 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo --draft<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h3 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo --cwd /path/to/cwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo server <span class="token comment">#启动本地服务器，用于预览主题。Hexo 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</span>hexo server -s <span class="token comment">#以静态模式启动</span>hexo server -p <span class="token number">5000</span> <span class="token comment">#更改访问端口 (默认端口为4000，'ctrl + c’关闭server)</span>hexo server -i IP地址 <span class="token comment">#自定义 IP</span>hexo clean <span class="token comment">#清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹</span>hexo g <span class="token comment">#生成静态网页 (执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将"/blog/source/" 下面的.md后缀的文件编译为.html后缀的文件,存放在"/blog/public/ " 路径下)</span>hexo d <span class="token comment">#自动生成网站静态文件，并将本地数据部署到设定的仓库(如github)</span>hexo init 文件夹名称 <span class="token comment">#初始化XX文件夹名称</span><span class="token function">npm</span> update hexo -g<span class="token comment">#升级</span><span class="token function">npm</span> <span class="token function">install</span> hexo -g <span class="token comment">#安装</span>node-v <span class="token comment">#查看node.js版本号</span><span class="token function">npm</span> -v <span class="token comment">#查看npm版本号</span><span class="token function">git</span> --version <span class="token comment">#查看git版本号</span>hexo -v <span class="token comment">#查看hexo版本号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="简写指令"><a href="#简写指令" class="headerlink" title="简写指令"></a>简写指令</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo n <span class="token string">"我的第一篇文章"</span> 等价于 hexo new <span class="token string">"我的第一篇文章"</span> 还等价于 hexo new post <span class="token string">"我的第一篇文章"</span>hexo p 等价于 hexo publishhexo g 等价于 hexo generatehexo s等价于 hexo serverhexo d 等价于 hexo deployhexo g -d等价于hexo generate --deploy注: hexo clean 没有 简写, <span class="token function">git</span> --version 没有简写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-theme-matery主题配置</title>
      <link href="/2022/04/26/hexo-theme-matery-zhu-ti-pei-zhi/"/>
      <url>/2022/04/26/hexo-theme-matery-zhu-ti-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul><li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li><li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li></ul><h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"categories"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"tags"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"about"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"contact"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token string">"friends"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: friendsdate: 2018-12-12 21:25:30type: "friends"layout: "friends"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">[</span><span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/1_qq_27922023.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"码酱"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"我不是大佬，只是在追寻大佬的脚步"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://luokangyuan.com/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/4027734.jpeg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"闪烁之狐"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://blinkfox.github.io/"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>    <span class="token property">"avatar"</span><span class="token operator">:</span> <span class="token string">"http://image.luokangyuan.com/avatar.jpg"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ja_rome"</span><span class="token punctuation">,</span>    <span class="token property">"introduction"</span><span class="token operator">:</span> <span class="token string">"平凡的脚步也可以走出伟大的行程"</span><span class="token punctuation">,</span>    <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://me.csdn.net/jlh912008548"</span><span class="token punctuation">,</span>    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"前去学习"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page <span class="token number">404</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: 404date: 2018-09-30 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>) 2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle  Friends:    url: /friends    icon: fas fa-address-book<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ol><li>在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)</li><li>在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 <code>-</code>.</li><li>注意缩进格式</li></ol><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">menu:  Index:    url: /    icon: fas fa-home  Tags:    url: /tags    icon: fas fa-tags  Categories:    url: /categories    icon: fas fa-bookmark  Archives:    url: /archives    icon: fas fa-archive  About:    url: /about    icon: fas fa-user-circle-o  Friends:    url: /friends    icon: fas fa-address-book  Medias:    icon: fas fa-list    children:      - name: Music        url: /music        icon: fas fa-music      - name: Movies        url: /movies        icon: fas fa-film      - name: Books        url: /books        icon: fas fa-book      - name: Galleries        url: /galleries        icon: fas fa-image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>从 Hexo5.0 版本开始自带了 <code>prismjs</code> 代码语法高亮的支持，本主题对此进行了改造支持。</p><p>如果你的博客中曾经安装过 <code>hexo-prism-plugin</code> 的插件，那么你须要执行 <code>npm uninstall hexo-prism-plugin</code> 来卸载掉它，否则生成的代码中会有 <code>{</code> 和 <code>}</code> 的转义字符。</p><p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并将 <code>prismjs.enable</code> 的值设置为 <code>true</code>，主要配置如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">highlight:  enable: false  line_number: true  auto_detect: false  tab_replace: ''  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: ''<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主题中默认的 <code>prismjs</code> 主题是 <code>Tomorrow Night</code>，如果你想定制自己的主题，可以前往 <a href="https://prismjs.com/download.html">prismjs 下载页面</a> 定制下载自己喜欢的主题 <code>css</code> 文件，然后将此 css 主题文件取名为 <code>prism.css</code>，替换掉 <code>hexo-theme-matery</code> 主题文件夹中的 <code>source/libs/prism/prism.css</code> 文件即可。</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i hexo-permalink-pinyin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">permalink_pinyin:  enable: true  separator: '-' # default: '-'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">postInfo:  date: true  update: false  wordCount: false # 设置文章字数统计为 true.  totalCount: false # 设置站点文章总字数统计为 true.  min2read: false # 阅读时长.  readCount: false # 阅读次数.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-filter-github-emojis --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p><h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;% if (theme.socialLink.github) { %&gt;    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= theme.socialLink.github %&gt;<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>tooltipped<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span> <span class="token attr-name">data-tooltip</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>访问我的GitHub<span class="token punctuation">"</span></span> <span class="token attr-name">data-position</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>top<span class="token punctuation">"</span></span> <span class="token attr-name">data-delay</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>50<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fab fa-github<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: <code>fab fa-facebook</code></li><li>Twitter: <code>fab fa-twitter</code></li><li>Google-plus: <code>fab fa-google-plus</code></li><li>Linkedin: <code>fab fa-linkedin</code></li><li>Tumblr: <code>fab fa-tumblr</code></li><li>Medium: <code>fab fa-medium</code></li><li>Slack: <code>fab fa-slack</code></li><li>Sina Weibo: <code>fab fa-weibo</code></li><li>Wechat: <code>fab fa-weixin</code></li><li>QQ: <code>fab fa-qq</code></li><li>Zhihu: <code>fab fa-zhihu</code></li></ul><blockquote><p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p></blockquote><h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml"># 是否在首页显示音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 503838841     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: false   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: true  # 列表默认折叠<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p><p><code>baidu</code>（百度音乐）。</p><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p><p>id<code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，</code>playlist<code>的</code>id即为这串数字。</p></blockquote><h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-md" data-language="md"><code class="language-md">---title: typora-vue-theme主题介绍date: 2018-09-07 09:25:00author: 赵奇img: /source/images/xxx.jpgtop: truehide: falsecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags:  - Typora  - Markdown---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><a href="https://camo.githubusercontent.com/ca91ff24a662fc02f64cfed3446fadc7d84dade01a698ebe3dd7b3710926489a/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67"><img src="https://camo.githubusercontent.com/ca91ff24a662fc02f64cfed3446fadc7d84dade01a698ebe3dd7b3710926489a/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d312e706e67" alt="首页"></a></p><p><a href="https://camo.githubusercontent.com/cc39895742d9eb7a90d25b8f4935be41a4feffc034eb1e3f665316699634e5cc/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d322e706e67"><img src="https://camo.githubusercontent.com/cc39895742d9eb7a90d25b8f4935be41a4feffc034eb1e3f665316699634e5cc/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d322e706e67" alt="首页推荐文章"></a></p><p><a href="https://camo.githubusercontent.com/a19a106d92f07d240643dfb8a2712fd0b2271d3dd6e24300732f2d96aac98393/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d332e706e67"><img src="https://camo.githubusercontent.com/a19a106d92f07d240643dfb8a2712fd0b2271d3dd6e24300732f2d96aac98393/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d332e706e67" alt="首页文章列表"></a></p><p><a href="https://camo.githubusercontent.com/44cacfc83c73411a8932d19fbfb3a24f49d39676837f84691796d258dd468a83/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d372e706e67"><img src="https://camo.githubusercontent.com/44cacfc83c73411a8932d19fbfb3a24f49d39676837f84691796d258dd468a83/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d372e706e67" alt="首页文章列表"></a></p><p><a href="https://camo.githubusercontent.com/552609ffbcb915e5630e8506adda1d15fdfbcc10c2517e5e5729ac0ea22842bd/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d382e706e67"><img src="https://camo.githubusercontent.com/552609ffbcb915e5630e8506adda1d15fdfbcc10c2517e5e5729ac0ea22842bd/687474703a2f2f7374617469632e626c696e6b666f782e636f6d2f6d61746572792d32303138313230322d382e706e67" alt="首页文章列表"></a></p><h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li><code>favicon</code> 和 <code>Logo</code></li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li><li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li></ul><p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p><h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p><pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><span class="token selector">.bg-color</span> <span class="token punctuation">{</span>    <span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token function">linear-gradient</span><span class="token punctuation">(</span>to right<span class="token punctuation">,</span> #4cbf30 0%<span class="token punctuation">,</span> #0f9d58 100%<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rainbow</span> <span class="token punctuation">{</span>   <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@keyframes</span> rainbow</span> <span class="token punctuation">{</span>    <span class="token comment">/* 动态切换背景颜色. */</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 `` 代码中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.bg-cover'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token string">'background-image'</span><span class="token punctuation">,</span> <span class="token string">'url(/medias/banner/'</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.jpg)'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/26/hello-world/"/>
      <url>/2022/04/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
